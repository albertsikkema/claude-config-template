"""Scan a dependency file for known vulnerabilities via OSV.dev batch API.

Usage: uv run python scan_deps.py <file_path> [--max-per-pkg N]

Supported files: package.json, requirements.txt, pyproject.toml, go.mod,
                 Cargo.toml, Gemfile.lock, pom.xml

Examples:
  uv run python scan_deps.py ./package.json
  uv run python scan_deps.py ./requirements.txt --max-per-pkg 5
"""

import argparse
import json
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent))

import httpx

import parsers
from osv_utils import extract_vuln_info

OSV_BATCH_LIMIT = 1000


def main():
    parser = argparse.ArgumentParser(description="Scan dependency file for vulnerabilities")
    parser.add_argument("file_path", help="Path to dependency file")
    parser.add_argument("--max-per-pkg", type=int, default=3, help="Max vulns per package (default 3)")
    args = parser.parse_args()

    file_path = str(Path(args.file_path).resolve())

    try:
        deps = parsers.parse_file(file_path)
    except (ValueError, FileNotFoundError) as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"error": f"Parse error: {e}"}))
        sys.exit(1)

    if not deps:
        print(json.dumps({"file": file_path, "total_deps": 0, "vulnerable": []}))
        return

    queries = []
    for name, version, ecosystem in deps:
        q = {"package": {"name": name, "ecosystem": ecosystem}}
        if version:
            q["version"] = version
        queries.append(q)

    # Query OSV in chunks to stay within batch API limits
    all_results = []
    for offset in range(0, len(queries), OSV_BATCH_LIMIT):
        chunk = queries[offset:offset + OSV_BATCH_LIMIT]
        try:
            resp = httpx.post("https://api.osv.dev/v1/querybatch", json={"queries": chunk}, timeout=30)
            resp.raise_for_status()
        except httpx.HTTPStatusError as e:
            print(json.dumps({"error": f"OSV batch API: HTTP {e.response.status_code}"}))
            sys.exit(1)
        except httpx.RequestError as e:
            print(json.dumps({"error": str(e)}))
            sys.exit(1)
        all_results.extend(resp.json().get("results", []))

    vulnerable = []
    for i, result in enumerate(all_results):
        vulns = result.get("vulns", [])
        if vulns:
            name, version, ecosystem = deps[i]
            pkg_vulns = [extract_vuln_info(v) for v in vulns[:args.max_per_pkg]]
            vulnerable.append({
                "name": name,
                "version": version,
                "ecosystem": ecosystem,
                "total_vulns": len(vulns),
                "vulnerabilities": pkg_vulns,
            })

    print(json.dumps({
        "file": file_path,
        "total_deps": len(deps),
        "vulnerable_count": len(vulnerable),
        "vulnerable": vulnerable,
    }, indent=2))


if __name__ == "__main__":
    main()
