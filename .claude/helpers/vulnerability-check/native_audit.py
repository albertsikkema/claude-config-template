"""Run ecosystem-native audit tools and normalize output to JSON.

Usage: uv run python native_audit.py <file_path>

Supported files and tools:
  package.json    -> npm audit
  requirements.txt -> pip-audit
  pyproject.toml  -> pip-audit
  go.mod          -> govulncheck
  Cargo.toml      -> cargo-audit
  Gemfile.lock    -> bundler-audit

If the native tool is not installed, returns {"status": "skipped"} gracefully.
"""

import argparse
import json
import shutil
import subprocess
import sys
from pathlib import Path

TOOL_MAP = {
    "package.json": ("npm", "npm", ["npm", "audit", "--json"]),
    "requirements.txt": ("PyPI", "pip-audit", ["pip-audit", "-r", "{file}", "--format", "json"]),
    "pyproject.toml": ("PyPI", "pip-audit", ["pip-audit", "--format", "json"]),
    "go.mod": ("Go", "govulncheck", ["govulncheck", "-json", "./..."]),
    "Cargo.toml": ("crates.io", "cargo-audit", ["cargo", "audit", "--json"]),
    "Gemfile.lock": ("RubyGems", "bundler-audit", ["bundle-audit", "check", "--format", "json"]),
}

TIMEOUT = 120


def find_tool(tool_name):
    """Check if a tool is available on PATH."""
    if tool_name == "pip-audit":
        if shutil.which("pip-audit"):
            return True
        # Fall back to module invocation
        try:
            result = subprocess.run(
                [sys.executable, "-m", "pip_audit", "--version"],
                capture_output=True, timeout=10,
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            return False
    if tool_name == "cargo-audit":
        return shutil.which("cargo") is not None
    if tool_name == "bundler-audit":
        return shutil.which("bundle-audit") is not None or shutil.which("bundler-audit") is not None
    return shutil.which(tool_name) is not None


def build_command(cmd_template, file_path):
    """Build the command list, substituting {file} with the actual path."""
    return [part.replace("{file}", str(file_path)) for part in cmd_template]


def run_tool(cmd, cwd):
    """Run the audit tool and return (stdout, stderr, returncode)."""
    # For pip-audit, if pip-audit not on PATH, use module invocation
    if cmd[0] == "pip-audit" and not shutil.which("pip-audit"):
        cmd = [sys.executable, "-m", "pip_audit"] + cmd[1:]

    # For bundler-audit, resolve actual binary name on PATH
    if cmd[0] == "bundle-audit" and not shutil.which("bundle-audit"):
        if shutil.which("bundler-audit"):
            cmd[0] = "bundler-audit"

    try:
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=TIMEOUT, cwd=cwd,
        )
        return result.stdout, result.stderr, result.returncode
    except subprocess.TimeoutExpired:
        return "", f"Tool timed out after {TIMEOUT}s", -1
    except FileNotFoundError:
        return "", "Tool executable not found", -2


# --- Per-tool normalizers ---

def normalize_npm(stdout):
    """Normalize npm audit --json output (npm v7+ format)."""
    data = json.loads(stdout)
    vulns = []
    seen = set()
    for pkg_name, info in data.get("vulnerabilities", {}).items():
        for via in info.get("via", []):
            if isinstance(via, dict):
                vid = via.get("url", "").rsplit("/", 1)[-1] if via.get("url") else via.get("name", "")
                if vid in seen:
                    continue
                seen.add(vid)
                vulns.append({
                    "id": vid,
                    "package": pkg_name,
                    "severity": via.get("severity", "unknown"),
                    "title": via.get("title", ""),
                    "installed_version": info.get("range", ""),
                    "fixed_version": info.get("fixAvailable", {}).get("version", "") if isinstance(info.get("fixAvailable"), dict) else "",
                    "url": via.get("url", ""),
                })
    return vulns


def normalize_pip_audit(stdout):
    """Normalize pip-audit --format json output."""
    data = json.loads(stdout)
    vulns = []
    # pip-audit 2.x outputs {"dependencies": [...], "fixes": [...]}, older versions output a bare list
    entries = data.get("dependencies", data) if isinstance(data, dict) else data
    for entry in entries:
        for v in entry.get("vulns", []):
            fix_versions = v.get("fix_versions", [])
            vulns.append({
                "id": v.get("id", ""),
                "package": entry.get("name", ""),
                "severity": "unknown",
                "title": v.get("description", v.get("id", "")),
                "installed_version": entry.get("version", ""),
                "fixed_version": fix_versions[0] if fix_versions else "",
                "url": f"https://osv.dev/vulnerability/{v.get('id', '')}",
            })
    return vulns


def normalize_govulncheck(stdout):
    """Normalize govulncheck -json output (NDJSON with finding messages)."""
    vulns = []
    # Try single JSON parse first
    try:
        data = json.loads(stdout)
        # govulncheck v1.0+ may produce a single JSON object
        for v in data.get("vulns", []):
            osv = v.get("osv", {})
            vulns.append({
                "id": osv.get("id", ""),
                "package": v.get("modules", [{}])[0].get("path", "") if v.get("modules") else "",
                "severity": "unknown",
                "title": osv.get("summary", ""),
                "installed_version": v.get("modules", [{}])[0].get("found_version", "") if v.get("modules") else "",
                "fixed_version": v.get("modules", [{}])[0].get("fixed_version", "") if v.get("modules") else "",
                "url": f"https://pkg.go.dev/vuln/{osv.get('id', '')}",
            })
        return vulns
    except (json.JSONDecodeError, AttributeError):
        pass

    # Fall back to line-by-line NDJSON
    seen_ids = set()
    for line in stdout.strip().splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            msg = json.loads(line)
        except json.JSONDecodeError:
            continue
        finding = msg.get("finding")
        if not finding:
            continue
        osv_id = finding.get("osv", "")
        if osv_id in seen_ids:
            continue
        seen_ids.add(osv_id)
        trace = finding.get("trace", [])
        module = trace[0].get("module", "") if trace else ""
        version = trace[0].get("version", "") if trace else ""
        vulns.append({
            "id": osv_id,
            "package": module,
            "severity": "unknown",
            "title": "",
            "installed_version": version,
            "fixed_version": "",
            "url": f"https://pkg.go.dev/vuln/{osv_id}",
        })
    return vulns


def normalize_cargo_audit(stdout):
    """Normalize cargo audit --json output."""
    data = json.loads(stdout)
    vulns = []
    for v in data.get("vulnerabilities", {}).get("list", []):
        advisory = v.get("advisory", {})
        patched = v.get("versions", {}).get("patched", [])
        vulns.append({
            "id": advisory.get("id", ""),
            "package": advisory.get("package", ""),
            "severity": "unknown",  # cargo-audit provides CVSS vector, not a label
            "title": advisory.get("title", ""),
            "installed_version": v.get("package", {}).get("version", ""),
            "fixed_version": patched[0] if patched else "",
            "url": advisory.get("url", ""),
        })
    return vulns


def normalize_bundler_audit(stdout):
    """Normalize bundle-audit check --format json output."""
    data = json.loads(stdout)
    vulns = []
    for r in data.get("results", []):
        advisory = r.get("advisory", {})
        vulns.append({
            "id": advisory.get("cve", advisory.get("id", "")),
            "package": r.get("gem", {}).get("name", ""),
            "severity": advisory.get("criticality", "unknown"),
            "title": advisory.get("title", ""),
            "installed_version": r.get("gem", {}).get("version", ""),
            "fixed_version": "",
            "url": advisory.get("url", ""),
        })
    return vulns


NORMALIZERS = {
    "npm": normalize_npm,
    "pip-audit": normalize_pip_audit,
    "govulncheck": normalize_govulncheck,
    "cargo-audit": normalize_cargo_audit,
    "bundler-audit": normalize_bundler_audit,
}


def main():
    parser = argparse.ArgumentParser(description="Run ecosystem-native audit tool")
    parser.add_argument("file_path", help="Path to dependency file")
    args = parser.parse_args()

    file_path = Path(args.file_path).resolve()
    filename = file_path.name

    if filename not in TOOL_MAP:
        print(json.dumps({
            "file": str(file_path),
            "status": "unsupported",
            "reason": f"No native audit tool for {filename}. Supported: {', '.join(sorted(TOOL_MAP))}",
        }))
        sys.exit(0)

    ecosystem, tool_name, cmd_template = TOOL_MAP[filename]

    if not find_tool(tool_name):
        print(json.dumps({
            "file": str(file_path),
            "ecosystem": ecosystem,
            "tool": tool_name,
            "status": "skipped",
            "reason": f"{tool_name} is not installed",
        }))
        sys.exit(0)

    cmd = build_command(cmd_template, file_path)
    cwd = str(file_path.parent)

    stdout, stderr, returncode = run_tool(cmd, cwd)

    if returncode in (-1, -2):
        print(json.dumps({
            "file": str(file_path),
            "ecosystem": ecosystem,
            "tool": tool_name,
            "status": "error",
            "reason": stderr,
        }))
        sys.exit(1)

    # Non-zero exit is normal for audit tools (means vulns found) â€” parse stdout
    if not stdout.strip():
        print(json.dumps({
            "file": str(file_path),
            "ecosystem": ecosystem,
            "tool": tool_name,
            "status": "error",
            "reason": f"{tool_name} produced no output",
            "raw_stderr": stderr[:500] if stderr else "",
        }))
        sys.exit(1)

    normalizer = NORMALIZERS.get(tool_name)
    if not normalizer:
        print(json.dumps({
            "file": str(file_path),
            "ecosystem": ecosystem,
            "tool": tool_name,
            "status": "error",
            "reason": f"No normalizer for {tool_name}",
        }))
        sys.exit(1)

    try:
        vulns = normalizer(stdout)
    except (json.JSONDecodeError, KeyError, IndexError, TypeError) as e:
        print(json.dumps({
            "file": str(file_path),
            "ecosystem": ecosystem,
            "tool": tool_name,
            "status": "error",
            "reason": f"Failed to parse {tool_name} output: {e}",
            "raw_stderr": stderr[:500] if stderr else "",
        }))
        sys.exit(1)

    print(json.dumps({
        "file": str(file_path),
        "ecosystem": ecosystem,
        "tool": tool_name,
        "status": "completed",
        "vulnerability_count": len(vulns),
        "vulnerabilities": vulns,
    }, indent=2))


if __name__ == "__main__":
    main()
