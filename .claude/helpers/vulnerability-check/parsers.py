"""Dependency file parsers for 7 common formats.

Each parser returns list[tuple[name, version, ecosystem]].
Version may be empty string if not pinned.
"""

import json
import re
import tomllib
import xml.etree.ElementTree as ET
from pathlib import Path


def parse_package_json(text: str) -> list[tuple[str, str, str]]:
    data = json.loads(text)
    deps: list[tuple[str, str, str]] = []
    for section in ("dependencies", "devDependencies"):
        for name, ver in data.get(section, {}).items():
            cleaned = re.sub(r"^[\^~>=<]*", "", ver).strip()
            deps.append((name, cleaned, "npm"))
    return deps


def parse_requirements_txt(text: str) -> list[tuple[str, str, str]]:
    deps: list[tuple[str, str, str]] = []
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith("#") or line.startswith("-"):
            continue
        match = re.match(r"^([A-Za-z0-9_.-]+)\s*==\s*([^\s;#]+)", line)
        if match:
            deps.append((match.group(1), match.group(2), "PyPI"))
        else:
            match = re.match(r"^([A-Za-z0-9_.-]+)", line)
            if match:
                deps.append((match.group(1), "", "PyPI"))
    return deps


def parse_pyproject_toml(text: str) -> list[tuple[str, str, str]]:
    data = tomllib.loads(text)
    deps: list[tuple[str, str, str]] = []
    # PEP 621
    for dep_str in data.get("project", {}).get("dependencies", []):
        match = re.match(r"^([A-Za-z0-9_.-]+)(?:\[.*?\])?\s*(?:==\s*([^\s;,]+))?", dep_str)
        if match:
            deps.append((match.group(1), match.group(2) or "", "PyPI"))
    # Poetry
    for name, val in data.get("tool", {}).get("poetry", {}).get("dependencies", {}).items():
        if name.lower() == "python":
            continue
        ver = val if isinstance(val, str) else val.get("version", "") if isinstance(val, dict) else ""
        cleaned = re.sub(r"^[\^~>=<]*", "", ver).strip()
        deps.append((name, cleaned, "PyPI"))
    return deps


def parse_go_mod(text: str) -> list[tuple[str, str, str]]:
    deps: list[tuple[str, str, str]] = []
    in_require = False
    for line in text.splitlines():
        line = line.strip()
        if line.startswith("require ("):
            in_require = True
            continue
        if in_require and line == ")":
            in_require = False
            continue
        if in_require:
            parts = line.split()
            if len(parts) >= 2 and not parts[0].startswith("//"):
                ver = parts[1].lstrip("v")
                deps.append((parts[0], ver, "Go"))
        elif line.startswith("require "):
            parts = line.split()
            if len(parts) >= 3:
                ver = parts[2].lstrip("v")
                deps.append((parts[1], ver, "Go"))
    return deps


def parse_cargo_toml(text: str) -> list[tuple[str, str, str]]:
    data = tomllib.loads(text)
    deps: list[tuple[str, str, str]] = []
    for section in ("dependencies", "dev-dependencies", "build-dependencies"):
        for name, val in data.get(section, {}).items():
            ver = val if isinstance(val, str) else val.get("version", "") if isinstance(val, dict) else ""
            cleaned = re.sub(r"^[\^~>=<]*", "", ver).strip()
            deps.append((name, cleaned, "crates.io"))
    return deps


def parse_gemfile_lock(text: str) -> list[tuple[str, str, str]]:
    deps: list[tuple[str, str, str]] = []
    in_specs = False
    for line in text.splitlines():
        if line.strip() == "specs:":
            in_specs = True
            continue
        if in_specs:
            match = re.match(r"^\s{4}(\S+)\s+\(([^)]+)\)", line)
            if match:
                deps.append((match.group(1), match.group(2), "RubyGems"))
            elif not line.startswith(" "):
                in_specs = False
    return deps


def parse_pom_xml(text: str) -> list[tuple[str, str, str]]:
    root = ET.fromstring(text)
    ns = ""
    if root.tag.startswith("{"):
        ns = root.tag.split("}")[0] + "}"
    deps: list[tuple[str, str, str]] = []
    for dep in root.iter(f"{ns}dependency"):
        group = dep.findtext(f"{ns}groupId", "")
        artifact = dep.findtext(f"{ns}artifactId", "")
        version = dep.findtext(f"{ns}version", "")
        if group and artifact:
            deps.append((f"{group}:{artifact}", version or "", "Maven"))
    return deps


PARSERS: dict[str, callable] = {
    "package.json": parse_package_json,
    "requirements.txt": parse_requirements_txt,
    "pyproject.toml": parse_pyproject_toml,
    "go.mod": parse_go_mod,
    "Cargo.toml": parse_cargo_toml,
    "Gemfile.lock": parse_gemfile_lock,
    "pom.xml": parse_pom_xml,
}


def parse_file(path: str) -> list[tuple[str, str, str]]:
    """Dispatch to the correct parser based on filename."""
    p = Path(path)
    parser = PARSERS.get(p.name)
    if parser is None:
        raise ValueError(f"Unsupported file: {p.name}. Supported: {', '.join(PARSERS.keys())}")
    return parser(p.read_text())
